
emacs--
  - awsome
  - configuration
     - .emacs vs init.el
               entry point to your own emacs fork
  - my configuration setup

  - functions & keybindings

  - files/buffers/inferior/shell

  - ido (& icicles)
 
  - windows management
       split
       switch

  - navigation, between words, lines etc...

 yank etc..
 \C-y -- yank
 \M-y -- rotate through kill ring
 \C-c k -- display kill ring
 \C-spacebar -- set mark
 \Esc W -- copy
 \Ctrl W -- copy
 \C-k -- kill line
 \C-/ -- undo

  - git


  - mention
    - etags 

python--
  indentation/syntax

  repl
  dir()
  help()
            interpreter:
           'python-switch-to-python \C-c\C-z 

           running tests
            \C-c\C-c --> to send to buffer
            \C-xx --> run in seperate proxess

            running a string
           \C-c\C-s


   in emacs ->

   moving around--->
    break code then use
 \M-g \M-g -- goto line x
 \M-g \M-n -- next error
 \M-g \M-p -- previous error
 

 


  testing

  snippets

   dicts = {:}
   list = []
   tuples = ()

   favour externally defined functions, e.g. map(), len() for orhoganol concetps, compated with ruby hat favours meta-programming

   favour strong types: concat int and string

  functions are good, first class citizens, no classes just for the sake of it.

  meta-programming, getattr, setattr


 goodness, list comprehension, generators, lambda, decorators (function aspects, built in)

refactoring:


rope:
M-/ -- complete
M-? -- lucky complete
\C-c f -- find occurances
\C-c d -- documentation
\C-c g -- go to definition

project:
\C-x p <>
 f -- find file
 n <>
   m -- create module
   p -- create project
   c -- create class
   f -- create file
   d -- create directory

refactoring:
\C-c r <>
 i -- inline
 m -- extracr method
 l -- extract variable
 r -- rename
 v -- move
 r -- resturcture
 u -- use function




 
  



  
